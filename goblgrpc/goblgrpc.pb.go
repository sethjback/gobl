// Code generated by protoc-gen-go. DO NOT EDIT.
// source: goblgrpc.proto

/*
Package goblgrpc is a generated protocol buffer package.

It is generated from these files:
	goblgrpc.proto

It has these top-level messages:
	ReturnMessage
	JobDefinition
	Path
	MEDefinition
	Option
	FileRequest
	File
	Signature
	Meta
*/
package goblgrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ReturnMessage struct {
	// message holds information about the call and detailed error information if there was a problem
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	// code for the particular call
	Code string `protobuf:"bytes,2,opt,name=code" json:"code,omitempty"`
}

func (m *ReturnMessage) Reset()                    { *m = ReturnMessage{} }
func (m *ReturnMessage) String() string            { return proto.CompactTextString(m) }
func (*ReturnMessage) ProtoMessage()               {}
func (*ReturnMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReturnMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ReturnMessage) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// JobDefinition contains all the data necessary to start a job
type JobDefinition struct {
	// id of the job
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// to is the array of datasinks (engines)
	To []*MEDefinition `protobuf:"bytes,2,rep,name=to" json:"to,omitempty"`
	// from is only used as the engine source for restores
	From *MEDefinition `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	// modifications to apply to the data stream before saving
	Modifications []*MEDefinition `protobuf:"bytes,4,rep,name=modifications" json:"modifications,omitempty"`
	// paths to backup
	Paths []*Path `protobuf:"bytes,5,rep,name=paths" json:"paths,omitempty"`
}

func (m *JobDefinition) Reset()                    { *m = JobDefinition{} }
func (m *JobDefinition) String() string            { return proto.CompactTextString(m) }
func (*JobDefinition) ProtoMessage()               {}
func (*JobDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *JobDefinition) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JobDefinition) GetTo() []*MEDefinition {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *JobDefinition) GetFrom() *MEDefinition {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *JobDefinition) GetModifications() []*MEDefinition {
	if m != nil {
		return m.Modifications
	}
	return nil
}

func (m *JobDefinition) GetPaths() []*Path {
	if m != nil {
		return m.Paths
	}
	return nil
}

// Path represents a location on the target file system to backup
type Path struct {
	// this is the root of the path
	Root string `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
	// exclusion patters to apply when traversing root
	Excludes []string `protobuf:"bytes,2,rep,name=excludes" json:"excludes,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Path) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *Path) GetExcludes() []string {
	if m != nil {
		return m.Excludes
	}
	return nil
}

// MEDefinition are configuration options for Mods and Engines
type MEDefinition struct {
	// name of the Mod or Engine
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// options
	Options []*Option `protobuf:"bytes,2,rep,name=options" json:"options,omitempty"`
}

func (m *MEDefinition) Reset()                    { *m = MEDefinition{} }
func (m *MEDefinition) String() string            { return proto.CompactTextString(m) }
func (*MEDefinition) ProtoMessage()               {}
func (*MEDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MEDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MEDefinition) GetOptions() []*Option {
	if m != nil {
		return m.Options
	}
	return nil
}

// Option used to configure engines and modifiers
type Option struct {
	// name of the option
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// value
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Option) Reset()                    { *m = Option{} }
func (m *Option) String() string            { return proto.CompactTextString(m) }
func (*Option) ProtoMessage()               {}
func (*Option) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Option) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Option) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type FileRequest struct {
	JobId string `protobuf:"bytes,1,opt,name=jobId" json:"jobId,omitempty"`
	File  *File  `protobuf:"bytes,2,opt,name=file" json:"file,omitempty"`
}

func (m *FileRequest) Reset()                    { *m = FileRequest{} }
func (m *FileRequest) String() string            { return proto.CompactTextString(m) }
func (*FileRequest) ProtoMessage()               {}
func (*FileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FileRequest) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *FileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type File struct {
	Signature *Signature `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
	Meta      *Meta      `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *File) GetSignature() *Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *File) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type Signature struct {
	Path          string   `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Hash          string   `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	Modifications []string `protobuf:"bytes,3,rep,name=modifications" json:"modifications,omitempty"`
}

func (m *Signature) Reset()                    { *m = Signature{} }
func (m *Signature) String() string            { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()               {}
func (*Signature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Signature) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Signature) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Signature) GetModifications() []string {
	if m != nil {
		return m.Modifications
	}
	return nil
}

type Meta struct {
	Mode uint32 `protobuf:"varint,1,opt,name=mode" json:"mode,omitempty"`
	Uid  int32  `protobuf:"varint,2,opt,name=uid" json:"uid,omitempty"`
	Gid  int32  `protobuf:"varint,3,opt,name=gid" json:"gid,omitempty"`
}

func (m *Meta) Reset()                    { *m = Meta{} }
func (m *Meta) String() string            { return proto.CompactTextString(m) }
func (*Meta) ProtoMessage()               {}
func (*Meta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Meta) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *Meta) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Meta) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func init() {
	proto.RegisterType((*ReturnMessage)(nil), "goblgrpc.ReturnMessage")
	proto.RegisterType((*JobDefinition)(nil), "goblgrpc.JobDefinition")
	proto.RegisterType((*Path)(nil), "goblgrpc.Path")
	proto.RegisterType((*MEDefinition)(nil), "goblgrpc.MEDefinition")
	proto.RegisterType((*Option)(nil), "goblgrpc.Option")
	proto.RegisterType((*FileRequest)(nil), "goblgrpc.FileRequest")
	proto.RegisterType((*File)(nil), "goblgrpc.File")
	proto.RegisterType((*Signature)(nil), "goblgrpc.Signature")
	proto.RegisterType((*Meta)(nil), "goblgrpc.Meta")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Agent service

type AgentClient interface {
	// Backup starts a backup job on the agent
	// this call should validate, configure, then start the job
	// agents can assume the job has been successfully create in the Coordinator
	// and thus all calls back to Backup Job related Coordinator endpoints will succeed.
	Backup(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error)
	// Restore starts a restore job.
	// this job should validate and configure the job. A success return from this call
	// guarantees any Restore Job related calls from the Coordinator will succeed.
	Restore(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error)
	// RestoreFile streams the individual files to restore
	// the Coordinator will stream individual file signatures previously recorded
	// from a backup job. The agent should queue these requests and run the restores
	// in parallel according to the job definition.
	RestoreFile(ctx context.Context, opts ...grpc.CallOption) (Agent_RestoreFileClient, error)
	// Terminate the job
	// agents should gracefully terminate any work currently associated with the job
	// before returning. Any queues dealing with outstanding work should be emptied,
	// but ongoing notification about already complete files
	// (i.e. calls to the Coordinator File call) should continue until acknowledged.
	Cancel(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Backup(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error) {
	out := new(ReturnMessage)
	err := grpc.Invoke(ctx, "/goblgrpc.Agent/Backup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Restore(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error) {
	out := new(ReturnMessage)
	err := grpc.Invoke(ctx, "/goblgrpc.Agent/Restore", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) RestoreFile(ctx context.Context, opts ...grpc.CallOption) (Agent_RestoreFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Agent_serviceDesc.Streams[0], c.cc, "/goblgrpc.Agent/RestoreFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentRestoreFileClient{stream}
	return x, nil
}

type Agent_RestoreFileClient interface {
	Send(*FileRequest) error
	CloseAndRecv() (*ReturnMessage, error)
	grpc.ClientStream
}

type agentRestoreFileClient struct {
	grpc.ClientStream
}

func (x *agentRestoreFileClient) Send(m *FileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentRestoreFileClient) CloseAndRecv() (*ReturnMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReturnMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) Cancel(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error) {
	out := new(ReturnMessage)
	err := grpc.Invoke(ctx, "/goblgrpc.Agent/Cancel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Agent service

type AgentServer interface {
	// Backup starts a backup job on the agent
	// this call should validate, configure, then start the job
	// agents can assume the job has been successfully create in the Coordinator
	// and thus all calls back to Backup Job related Coordinator endpoints will succeed.
	Backup(context.Context, *JobDefinition) (*ReturnMessage, error)
	// Restore starts a restore job.
	// this job should validate and configure the job. A success return from this call
	// guarantees any Restore Job related calls from the Coordinator will succeed.
	Restore(context.Context, *JobDefinition) (*ReturnMessage, error)
	// RestoreFile streams the individual files to restore
	// the Coordinator will stream individual file signatures previously recorded
	// from a backup job. The agent should queue these requests and run the restores
	// in parallel according to the job definition.
	RestoreFile(Agent_RestoreFileServer) error
	// Terminate the job
	// agents should gracefully terminate any work currently associated with the job
	// before returning. Any queues dealing with outstanding work should be emptied,
	// but ongoing notification about already complete files
	// (i.e. calls to the Coordinator File call) should continue until acknowledged.
	Cancel(context.Context, *JobDefinition) (*ReturnMessage, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Backup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Backup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/goblgrpc.Agent/Backup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Backup(ctx, req.(*JobDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/goblgrpc.Agent/Restore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Restore(ctx, req.(*JobDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_RestoreFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).RestoreFile(&agentRestoreFileServer{stream})
}

type Agent_RestoreFileServer interface {
	SendAndClose(*ReturnMessage) error
	Recv() (*FileRequest, error)
	grpc.ServerStream
}

type agentRestoreFileServer struct {
	grpc.ServerStream
}

func (x *agentRestoreFileServer) SendAndClose(m *ReturnMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentRestoreFileServer) Recv() (*FileRequest, error) {
	m := new(FileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Agent_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/goblgrpc.Agent/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Cancel(ctx, req.(*JobDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "goblgrpc.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Backup",
			Handler:    _Agent_Backup_Handler,
		},
		{
			MethodName: "Restore",
			Handler:    _Agent_Restore_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Agent_Cancel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RestoreFile",
			Handler:       _Agent_RestoreFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "goblgrpc.proto",
}

// Client API for Coordinator service

type CoordinatorClient interface {
	// File accepts data about completed job files
	// FileRequests sent in this call should only represent files that have been completed
	// e.g. completely backed up or restored.
	File(ctx context.Context, opts ...grpc.CallOption) (Coordinator_FileClient, error)
	// Finish indicates all work for the particular job definition has been completed
	// by the agent. Any additional calls related to the particular definition will fail
	Finish(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error)
}

type coordinatorClient struct {
	cc *grpc.ClientConn
}

func NewCoordinatorClient(cc *grpc.ClientConn) CoordinatorClient {
	return &coordinatorClient{cc}
}

func (c *coordinatorClient) File(ctx context.Context, opts ...grpc.CallOption) (Coordinator_FileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Coordinator_serviceDesc.Streams[0], c.cc, "/goblgrpc.Coordinator/File", opts...)
	if err != nil {
		return nil, err
	}
	x := &coordinatorFileClient{stream}
	return x, nil
}

type Coordinator_FileClient interface {
	Send(*FileRequest) error
	CloseAndRecv() (*ReturnMessage, error)
	grpc.ClientStream
}

type coordinatorFileClient struct {
	grpc.ClientStream
}

func (x *coordinatorFileClient) Send(m *FileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *coordinatorFileClient) CloseAndRecv() (*ReturnMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ReturnMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *coordinatorClient) Finish(ctx context.Context, in *JobDefinition, opts ...grpc.CallOption) (*ReturnMessage, error) {
	out := new(ReturnMessage)
	err := grpc.Invoke(ctx, "/goblgrpc.Coordinator/Finish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Coordinator service

type CoordinatorServer interface {
	// File accepts data about completed job files
	// FileRequests sent in this call should only represent files that have been completed
	// e.g. completely backed up or restored.
	File(Coordinator_FileServer) error
	// Finish indicates all work for the particular job definition has been completed
	// by the agent. Any additional calls related to the particular definition will fail
	Finish(context.Context, *JobDefinition) (*ReturnMessage, error)
}

func RegisterCoordinatorServer(s *grpc.Server, srv CoordinatorServer) {
	s.RegisterService(&_Coordinator_serviceDesc, srv)
}

func _Coordinator_File_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CoordinatorServer).File(&coordinatorFileServer{stream})
}

type Coordinator_FileServer interface {
	SendAndClose(*ReturnMessage) error
	Recv() (*FileRequest, error)
	grpc.ServerStream
}

type coordinatorFileServer struct {
	grpc.ServerStream
}

func (x *coordinatorFileServer) SendAndClose(m *ReturnMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *coordinatorFileServer) Recv() (*FileRequest, error) {
	m := new(FileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Coordinator_Finish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinatorServer).Finish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/goblgrpc.Coordinator/Finish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinatorServer).Finish(ctx, req.(*JobDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

var _Coordinator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "goblgrpc.Coordinator",
	HandlerType: (*CoordinatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finish",
			Handler:    _Coordinator_Finish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "File",
			Handler:       _Coordinator_File_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "goblgrpc.proto",
}

func init() { proto.RegisterFile("goblgrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 518 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6f, 0xd3, 0x30,
	0x18, 0x26, 0x69, 0xd2, 0xae, 0x6f, 0x68, 0x35, 0x99, 0xaf, 0x68, 0xa7, 0xca, 0x9a, 0x50, 0xb5,
	0xc3, 0x24, 0x82, 0xc4, 0x01, 0x6d, 0x48, 0x63, 0x30, 0x04, 0x52, 0x01, 0x99, 0x13, 0x07, 0x0e,
	0x6e, 0xe2, 0x26, 0x86, 0x24, 0x0e, 0xb1, 0x83, 0xf8, 0x03, 0x88, 0x9f, 0xc8, 0xdf, 0x41, 0xb6,
	0x93, 0x66, 0x29, 0xa8, 0x87, 0xde, 0x9e, 0xf7, 0xe3, 0x79, 0xfc, 0x7e, 0x25, 0x30, 0x4f, 0xc5,
	0x3a, 0x4f, 0xeb, 0x2a, 0x3e, 0xaf, 0x6a, 0xa1, 0x04, 0x3a, 0xea, 0x6c, 0x7c, 0x09, 0x33, 0xc2,
	0x54, 0x53, 0x97, 0x2b, 0x26, 0x25, 0x4d, 0x19, 0x0a, 0x61, 0x52, 0x58, 0x18, 0x3a, 0x0b, 0x67,
	0x39, 0x25, 0x9d, 0x89, 0x10, 0x78, 0xb1, 0x48, 0x58, 0xe8, 0x1a, 0xb7, 0xc1, 0xf8, 0x8f, 0x03,
	0xb3, 0x77, 0x62, 0xfd, 0x8a, 0x6d, 0x78, 0xc9, 0x15, 0x17, 0x25, 0x9a, 0x83, 0xcb, 0x93, 0x96,
	0xea, 0xf2, 0x04, 0x3d, 0x06, 0x57, 0x89, 0xd0, 0x5d, 0x8c, 0x96, 0x41, 0xf4, 0xf0, 0x7c, 0x5b,
	0xc7, 0xea, 0x75, 0xcf, 0x21, 0xae, 0x12, 0xe8, 0x0c, 0xbc, 0x4d, 0x2d, 0x8a, 0x70, 0xb4, 0x70,
	0xf6, 0x64, 0x9a, 0x1c, 0x74, 0x01, 0xb3, 0x42, 0x24, 0x7c, 0xc3, 0x63, 0xaa, 0xbd, 0x32, 0xf4,
	0xf6, 0xca, 0x0f, 0x93, 0xd1, 0x29, 0xf8, 0x15, 0x55, 0x99, 0x0c, 0x7d, 0xc3, 0x9a, 0xf7, 0xac,
	0x8f, 0x54, 0x65, 0xc4, 0x06, 0xf1, 0x33, 0xf0, 0xb4, 0xa9, 0xbb, 0xae, 0x85, 0x50, 0x6d, 0x47,
	0x06, 0xa3, 0x13, 0x38, 0x62, 0x3f, 0xe3, 0xbc, 0x49, 0x98, 0x34, 0x9d, 0x4d, 0xc9, 0xd6, 0xc6,
	0xef, 0xe1, 0xee, 0xed, 0xc7, 0x35, 0xbf, 0xa4, 0x45, 0x37, 0x4c, 0x83, 0xd1, 0x19, 0x4c, 0x44,
	0x65, 0x2b, 0xb7, 0x83, 0x39, 0xee, 0x6b, 0xf8, 0x60, 0x02, 0xa4, 0x4b, 0xc0, 0x11, 0x8c, 0xad,
	0xeb, 0xbf, 0x4a, 0xf7, 0xc1, 0xff, 0x41, 0xf3, 0xa6, 0x5b, 0x8a, 0x35, 0xf0, 0x1b, 0x08, 0x6e,
	0x78, 0xce, 0x08, 0xfb, 0xde, 0x30, 0xa9, 0x74, 0xd2, 0x57, 0xb1, 0x7e, 0xdb, 0x6d, 0xc5, 0x1a,
	0x08, 0x83, 0xb7, 0xe1, 0xb9, 0x65, 0x0e, 0xa6, 0x60, 0xa8, 0x26, 0x86, 0xbf, 0x80, 0xa7, 0x2d,
	0xf4, 0x04, 0xa6, 0x92, 0xa7, 0x25, 0x55, 0x4d, 0x6d, 0xdf, 0x0f, 0xa2, 0x7b, 0x3d, 0xe1, 0x53,
	0x17, 0x22, 0x7d, 0x96, 0x96, 0x2f, 0x98, 0xa2, 0xff, 0xca, 0xaf, 0x98, 0xa2, 0xc4, 0xc4, 0xf0,
	0x67, 0x98, 0x6e, 0xb9, 0xba, 0x3d, 0x3d, 0xf9, 0xae, 0xbd, 0xaa, 0x1d, 0x7e, 0x46, 0x65, 0xd6,
	0x9d, 0x9c, 0xc6, 0xe8, 0x74, 0x77, 0xf9, 0x23, 0xb3, 0x81, 0xa1, 0x13, 0xbf, 0x00, 0x4f, 0x3f,
	0xa4, 0x15, 0x0a, 0x7d, 0xb4, 0x5a, 0x75, 0x46, 0x0c, 0x46, 0xc7, 0x30, 0x6a, 0x78, 0x62, 0x44,
	0x7d, 0xa2, 0xa1, 0xf6, 0xa4, 0x3c, 0x31, 0xb7, 0xe7, 0x13, 0x0d, 0xa3, 0x5f, 0x2e, 0xf8, 0x57,
	0x29, 0x2b, 0x15, 0xba, 0x80, 0xf1, 0x4b, 0x1a, 0x7f, 0x6b, 0x2a, 0xf4, 0xa8, 0x6f, 0x62, 0x70,
	0xf3, 0x27, 0xb7, 0x02, 0x83, 0x8f, 0x09, 0xdf, 0x41, 0x97, 0x30, 0x21, 0x4c, 0x2a, 0x51, 0xb3,
	0x83, 0xe8, 0x57, 0x10, 0xb4, 0x74, 0xb3, 0x87, 0x07, 0x3b, 0x5b, 0xb2, 0x0b, 0xde, 0x23, 0xb0,
	0x74, 0x74, 0xfd, 0xd7, 0xb4, 0x8c, 0x59, 0x7e, 0x48, 0x01, 0xd1, 0x6f, 0x07, 0x82, 0x6b, 0x21,
	0xea, 0x84, 0x97, 0x54, 0x89, 0x1a, 0x3d, 0x6f, 0x2f, 0xe2, 0xc0, 0x4a, 0x6e, 0x78, 0xc9, 0x65,
	0x76, 0x48, 0x25, 0xeb, 0xb1, 0xf9, 0x75, 0x3d, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xc7,
	0x55, 0x25, 0xcc, 0x04, 0x00, 0x00,
}
